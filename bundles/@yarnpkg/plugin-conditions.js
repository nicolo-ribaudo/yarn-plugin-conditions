/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-conditions",
factory: function (require) {
var plugin=(()=>{var le=Object.create,L=Object.defineProperty,pe=Object.defineProperties,de=Object.getOwnPropertyDescriptor,ue=Object.getOwnPropertyDescriptors,fe=Object.getOwnPropertyNames,Y=Object.getOwnPropertySymbols,me=Object.getPrototypeOf,B=Object.prototype.hasOwnProperty,ge=Object.prototype.propertyIsEnumerable;var M=(t,e,n)=>e in t?L(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,$=(t,e)=>{for(var n in e||(e={}))B.call(e,n)&&M(t,n,e[n]);if(Y)for(var n of Y(e))ge.call(e,n)&&M(t,n,e[n]);return t},Q=(t,e)=>pe(t,ue(e)),he=t=>L(t,"__esModule",{value:!0});var h=t=>{if(typeof require!="undefined")return require(t);throw new Error('Dynamic require of "'+t+'" is not supported')};var ye=(t,e)=>{for(var n in e)L(t,n,{get:e[n],enumerable:!0})},ke=(t,e,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of fe(e))!B.call(t,o)&&o!=="default"&&L(t,o,{get:()=>e[o],enumerable:!(n=de(e,o))||n.enumerable});return t},y=t=>ke(he(L(t!=null?le(me(t)):{},"default",t&&t.__esModule&&"default"in t?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);var $e={};ye($e,{default:()=>je});var N=y(h("@yarnpkg/core"));var v=y(h("@yarnpkg/core"));function K(t){var b,O;let e="condition:";if(!t.startsWith(e,0))throw new Error(`Expected 'condition:' at index 0 (${t})`);let n=e.length;p();let o=d(/[\w-]+/y);if(!o)throw new Error(`Expected an identifier at index ${n} (${t})`);p(),c("?"),p();let i=null;t[n]==="("?i=u().trim()||null:t[n]!==":"&&(i=((b=d(/[^(:]+/y))==null?void 0:b.trimRight())||null),c(":"),p();let r=null;n<t.length&&(t[n]==="("&&!t.startsWith("esm:",n+1)?r=u().trim()||null:t[n]!==":"&&(r=((O=d(/[^(#]+/y))==null?void 0:O.trimRight())||null));let s=k("esm"),a=k("peer");!s&&a&&(s=k("esm"));let l=null;if(n<t.length&&t[n]==="#"&&(n++,l=d(/\w+/y),p()),n!==t.length)throw new Error(`Unexpected '${t[n]}' at index ${n} (${t})`);return{test:o,consequent:i,alternate:r,esmExports:s,peers:a,hash:l};function c(m){if(t[n]!==m)throw new Error(`Expected '${m}' at index ${n} (${t})`);n++}function p(){d(/\s*/y)}function d(m){m.lastIndex=n;let f=m.exec(t);return f?(n+=f[0].length,f[0]):null}function u(){c("(");let m=1,f="";for(;m;){if(n===t.length)throw new Error(`Expected ')' at index ${n} (${t})`);let g=t[n];g==="("&&m++,g===")"&&m--,(g!==")"||m>0)&&(f+=g),n++}return p(),f}function k(m){if(n<t.length&&t.startsWith(`(${m}:`,n)){let f=u().slice(m.length+1).trim();if(f)return f.split(",").map(g=>g.trim())}return null}}var q=["dependencies","devDependencies","peerDependencies"],G=11;function x(t){return t.startsWith("condition:")}function Z(t){try{return K(t)}catch(e){try{let{test:n,consequent:o,alternate:i,esmExports:r,peers:s}=v.structUtils.parseRange(t).params;return{test:n,consequent:o||null,alternate:i||null,esmExports:r||null,peers:s||null}}catch{throw e}}}function C(t){return Z(t.range)}function T(t){return Z(t.reference)}function Pe({test:t,consequent:e,alternate:n,esmExports:o,peers:i,hash:r}){let s=`condition:${t}?`;return e&&(s+=e),s+=":",n&&(s+=n),o&&(s+=`(esm:${o.join(",")})`),i&&(s+=`(peer:${i.join(",")})`),r&&(s+=`#${r}`),s}function X(t,{test:e,consequent:n,alternate:o,esmExports:i,peers:r,hash:s}){return v.structUtils.makeLocator(t,Pe({test:e,consequent:n,alternate:o,esmExports:i,peers:r,hash:s}))}function w(t,e,n,o,i){let r=v.structUtils.makeIdent(e.scope,`${e.name}-${n}-${i}`),s=t.configuration.get("defaultProtocol")+`${v.structUtils.stringifyIdent(e)}@${o}`;return v.structUtils.makeDescriptor(r,s)}function R(t,e,n,o,i,r){return v.hashUtils.makeHash(String(G),t,e||"-",n||"-",(o==null?void 0:o.join(","))||"-",(i==null?void 0:i.join(","))||"-",r?"1":"0").slice(0,6)}var H=y(h("@yarnpkg/core")),ee={conditions:{description:"",type:H.SettingsType.MAP,valueDefinition:{description:"",type:H.SettingsType.SHAPE,properties:{source:{description:"",type:H.SettingsType.STRING,default:"env"},default:{description:"",type:H.SettingsType.BOOLEAN,default:!1}}}}};function I(t,e){if(!t.configuration.get("conditions").has(e))throw new Error(`Unknown condition: ${e}. You must add it to your .yarnrc.yml file.`)}function S(t,e){return I(t,e),t.configuration.get("conditions").get(e).get("default")}function F(t,e){var r;I(t,e);let n=t.configuration.get("conditions").get(e),o=n.get("source"),i=n.get("default");if(o!=="env")throw new Error("The only supported configuration source is 'env'");return(r=xe(process.env[e]))!=null?r:i}function xe(t){return t&&t!=="false"&&t!=="0"}var _=class{supportsDescriptor(e){return x(e.range)}supportsLocator(e){return x(e.reference)}shouldPersistResolution(){return!1}bindDescriptor(e){return e}getResolutionDependencies(e,n){let{test:o,consequent:i,alternate:r,esmExports:s}=C(e);return[i&&w(n.project,e,o,i,!0),r&&w(n.project,e,o,r,!1)].filter(Boolean)}async getCandidates(e,n,o){let{test:i,consequent:r,alternate:s,esmExports:a,peers:l}=C(e),c=R(i,r,s,a,l,S(o.project,i));return[X(e,{test:i,consequent:r,alternate:s,esmExports:a,peers:l,hash:c})]}async getSatisfying(){return null}async resolve(e,n){let{test:o,consequent:i,alternate:r,esmExports:s,peers:a}=T(e),l=R(o,i,r,s,a,S(n.project,o)),c=i&&w(n.project,e,o,i,!0),p=r&&w(n.project,e,o,r,!1);return Q($({},e),{version:`0.0.0-condition-${l}`,languageName:n.project.configuration.get("defaultLanguageName"),linkType:N.LinkType.HARD,dependencies:new Map([i&&[c.identHash,c],r&&[p.identHash,p]].filter(Boolean)),peerDependencies:new Map((a||[]).map(d=>{let u=N.structUtils.parseDescriptor(`${d}@*`);return[u.identHash,u]})),dependenciesMeta:new Map,peerDependenciesMeta:new Map,bin:null})}};var W=y(h("@yarnpkg/core"));var te=y(h("@yarnpkg/core")),D=y(h("@yarnpkg/fslib")),ne=y(h("@yarnpkg/libzip")),oe=15805116e5;async function ie(t,e,n,o,i){let[r,s]=await Promise.all([D.xfs.mktempPromise(),(0,ne.getLibzipPromise)()]),a=D.ppath.join(r,"condition.zip"),l=te.structUtils.getIdentVendorPath(t),c=new D.ZipFS(a,{libzip:s,create:!0,level:e.configuration.get("compressionLevel")});return await c.mkdirpPromise(l),await Promise.all([c.writeJsonPromise(D.ppath.join(l,"package.json"),n),c.writeFilePromise(D.ppath.join(l,"index.js"),o),i&&c.writeFilePromise(D.ppath.join(l,"index.mjs"),i)]),await Promise.all(c.getAllFiles().map(p=>c.utimesPromise(p,oe,oe))),c}var z=class{supports(e){return x(e.reference)}getLocalPath(){return null}async fetch(e,n){let o=n.checksums.get(e.locatorHash)||null,[i,r,s]=await n.cache.fetchPackageFromCache(e,o,{onHit:()=>n.report.reportCacheHit(e),onMiss:()=>n.report.reportCacheMiss(e,`${W.structUtils.prettyLocator(n.project.configuration,e)} can't be found in the cache and will be fetched from the disk`),loader:()=>this.generateConditionPackage(e,n),skipIntegrityCheck:n.skipIntegrityCheck});return{packageFs:i,releaseFs:r,prefixPath:W.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(),checksum:s}}async generateConditionPackage(e,n){let{test:o,consequent:i,alternate:r,esmExports:s,peers:a}=T(e),l=S(n.project,o),c=R(o,i,r,s,a,l),p=(f,g)=>{if(f==null)return{dependency:null,require:"null",esmHeader:"",imported:"{ __proto__: null }"};let j=w(n.project,e,o,f,g),V=W.structUtils.stringifyIdent(j),J=`if_${g}`;return{dependency:{[V]:j.range},require:`require(${JSON.stringify(V)})`,esmHeader:`import * as ${J} from ${JSON.stringify(V)};`,imported:J}},d=p(i,!0),u=p(r,!1),k=$($({version:`0.0.0-condition-${c}`,dependencies:$($({},d.dependency),u.dependency)},s&&{exports:{require:"./index.js",default:"./index.mjs"}}),a&&{peerDependencies:Object.fromEntries(a.map(f=>[f,"*"]))}),b=`// env vars from the cli are always strings, so !!ENV_VAR returns true for "false"
function bool(value) {
  if (value == null) return ${l};
  return value && value !== "false" && value !== "0";
}
`,O=`${b}
module.exports = bool(process.env[${JSON.stringify(o)}])
  ? ${d.require}
  : ${u.require};
`,m=null;if(s){O+=`0 && (${s.map(j=>`exports.${j} = `).join("")} 0);`;let f=!1,g=[];for(let j of s)j==="default"?f=!0:g.push(j);m=`${b}
${d.esmHeader}
${u.esmHeader}

export const { ${g.join(", ")} } = bool(process.env[${JSON.stringify(o)}]) ? ${d.imported} : ${u.imported};
${f&&`export default (bool(process.env[${JSON.stringify(o)}]) ? ${d.imported} : ${u.imported}).default;`}
`}return ie(e,n.project,k,O,m)}};var A=y(h("@yarnpkg/core"));var De=Function.call.bind(Object.prototype.hasOwnProperty);async function re(t,e){var i;let{project:n}=t,o=!1;for(let r of q){let s=t.manifest.getForScope(r).values();for(let a of s){if(!x(a.range))continue;let{test:l,consequent:c,alternate:p}=C(a),d=F(n,l)?c:p,u=A.structUtils.stringifyIdent(a),k=r==="dependencies"&&!e.dependencies[u]&&((i=e.optionalDependencies)==null?void 0:i[u])?"optionalDependencies":r;d?(e[k][u]=d,t.manifest.raw[k][u]=d,t.manifest[r].set(a.identHash,A.structUtils.makeDescriptor(a,d))):(delete e[k][u],delete t.manifest.raw[k][u],t.manifest[r].delete(a.identHash)),o=!0}}if(De(e,"conditions")){o=!0;let r=e.conditions;for(let[s,[a,l]]of Object.entries(r)){let c=F(n,s)?a:l;if(c)for(let[p,d]of Object.entries(c))d===null?delete e[p]:e[p]=d}delete e.conditions}o&&await t.project.configuration.triggerHook(r=>r.beforeWorkspacePacking,t,e)}var P=y(h("@yarnpkg/core")),se=y(h("@yarnpkg/cli")),E=y(h("clipanion")),ae=y(h("typanion"));var ve=Function.call.bind(Object.prototype.hasOwnProperty),ce=(t,e,...n)=>ve(t,e)&&(n.length===0||ce(t[e],...n)),U=class extends se.BaseCommand{constructor(){super(...arguments);this.condition=E.Option.String({required:!0});this.true=E.Option.Boolean("--true",!1);this.false=E.Option.Boolean("--false",!1)}async execute(){let{project:e,workspace:n,cache:o,configuration:i}=await this.getRoot();I(e,this.condition);let r=this.false?!1:this.true?!0:F(e,this.condition);for(let a of this.nestedWorkspaces(n,e))this.materializeCondition(r,a);let s=await P.StreamReport.start({configuration:i,stdout:this.context.stdout,includeLogs:!0},async a=>{await e.resolveEverything({cache:o,report:a})});if(s.hasErrors())return s.exitCode();await e.persist()}*nestedWorkspaces(e,n){yield e;for(let o of e.workspacesCwds){let i=n.workspacesByCwd.get(o);i&&(yield*this.nestedWorkspaces(i,n))}}materializeCondition(e,n){for(let i of q){let r=n.manifest.getForScope(i).values();for(let s of r){if(!x(s.range))continue;let{test:a,consequent:l,alternate:c}=C(s);if(a!==this.condition)continue;let p=e?l:c;p?n.manifest[i].set(s.identHash,P.structUtils.makeDescriptor(s,p)):n.manifest[i].delete(s.identHash)}}let o=n.manifest.raw;if(ce(o,"conditions",this.condition)){let[i,r]=o.conditions[this.condition],s=e?i:r;if(s)for(let[a,l]of Object.entries(s))l===null?delete o[a]:o[a]=l;Object.keys(o.conditions).length===1?delete o.conditions:delete o.conditions[this.condition]}}async getRoot(){let e=await P.Configuration.find(this.context.cwd,this.context.plugins),[{project:n,workspace:o},i]=await Promise.all([P.Project.find(e,this.context.cwd),P.Cache.find(e,{immutable:!0})]);return{configuration:e,project:n,workspace:o,cache:i}}};U.paths=[["condition","materialize"]],U.usage=E.Command.Usage({description:"Evaluate and replace a condition in package.json files",details:"\n      This command will replace all the occurrences of `<condition>` in the current workspace and in nested workspaces.\n\n      The value of the condition (`true` or `false`) is based on the following sources, in descending priority order:\n\n      - the `--true` or `--false` option;\n      - the `<condition>` environment variable;\n      - the default value specified in the Yarn configuration;\n      - `false` by default.\n    "}),U.schema=[ae.hasMutuallyExclusiveKeys(["true","false"])];var je={configuration:ee,commands:[U],fetchers:[z],resolvers:[_],hooks:{beforeWorkspacePacking:re}};return $e;})();
return plugin;
}
};
